"""
Main application for the anti-erotic-spam Telegram bot.
"""
import os
import time
import logging
from typing import Dict, Any

from fastapi import FastAPI, Request, HTTPException, Depends
from fastapi.responses import JSONResponse

import telegram
from telegram import Update, Bot
from telegram.error import TelegramError

from openai import OpenAI

from config import config
from bot.auth import verify_jwt, validate_telegram_request
from bot.avatar_analyzer import check_avatar
from bot.spam_classifier import classify_message, needs_classification
from bot.database import (
    create_db_pool, initialize_tables, log_message, mark_new_member,
    check_pending, clear_pending, get_bot_enabled_state, set_bot_enabled_state,
    get_stats
)
from bot.telegram_utils import check_bio_for_links, take_action, extract_user_and_chat
from bot.metrics import (
    timed_execution, increment_counter, set_gauge,
    spam_detected, avatar_unsafe, avatar_suspicious,
    webhook_requests, webhook_errors, llm_latency,
    avatar_check_latency, webhook_latency,
    detector_initialized, bot_enabled
)


# Configure logging
logging.basicConfig(level=getattr(logging, config.LOG_LEVEL.upper(), logging.INFO))
logger = logging.getLogger(__name__)

# Initialize FastAPI
app = FastAPI()

# Initialize Telegram Bot
bot = Bot(token=config.TG_TOKEN)


@app.on_event("startup")
async def on_startup():
    """
    Initialize application on startup.
    """
    # Initialize OpenAI client
    app.state.openai_client = OpenAI(api_key=config.OPENAI_KEY)
    
    # Connect to PostgreSQL with retries
    app.state.db = await create_db_pool(config.POSTGRES_DSN)
    
    # Initialize database tables
    await initialize_tables(app.state.db)
    
    # Set bot enabled gauge
    enabled = await get_bot_enabled_state(app.state.db)
    set_gauge(bot_enabled, 1 if enabled else 0)


@app.on_event("shutdown")
async def on_shutdown():
    """
    Clean up resources on shutdown.
    """
    if hasattr(app.state, "db") and app.state.db is not None:
        await app.state.db.close()
        logger.info("Database connection pool closed")


@app.post("/webhook")
async def webhook(request: Request):
    """
    Telegram webhook endpoint to receive updates.
    """
    # Increment webhook request counter
    increment_counter(webhook_requests)
    
    # Start timing webhook request
    with timed_execution(webhook_latency):
        # Validate webhook request
        if config.WEBHOOK_SECRET and not validate_telegram_request(config.WEBHOOK_SECRET, request.headers):
            increment_counter(webhook_errors)
            raise HTTPException(status_code=403, detail="Unauthorized")
        
        # Check if bot is enabled
        enabled = await get_bot_enabled_state(app.state.db)
        if not enabled:
            return JSONResponse({"ok": True})
        
        # Parse update
        try:
            data = await request.json()
            update = Update.de_json(data, bot)
        except Exception as e:
            logger.error("Failed to parse update: %s", e)
            increment_counter(webhook_errors)
            raise HTTPException(status_code=400, detail="Invalid update payload")
        
        message = update.message
        
        # Handle new chat members: mark for first-message check
        if message and message.new_chat_members:
            for new_member in message.new_chat_members:
                await mark_new_member(app.state.db, message.chat.id, new_member.id)
            return JSONResponse({"ok": True})
        
        # Only process the first message per user after joining
        if not message or not message.text:
            return JSONResponse({"ok": True})
        
        user = message.from_user
        chat = message.chat
        
        # Check pending-first flag
        pending = await check_pending(app.state.db, chat.id, user.id)
        if not pending:
            # Not a first message after join: skip
            return JSONResponse({"ok": True})
        
        # Clear pending flag so we only check once
        await clear_pending(app.state.db, chat.id, user.id)
        
        msg_text = message.text
        
        # Check for links in bio
        bio, link_in_bio = await check_bio_for_links(bot, user.id)
        
        # Check avatar for NSFW content
        with timed_execution(avatar_check_latency):
            avatar_unsafe_result, avatar_suspicious_result = await check_avatar(bot, user.id)
        
        # Update metrics
        if avatar_unsafe_result:
            increment_counter(avatar_unsafe)
        if avatar_suspicious_result:
            increment_counter(avatar_suspicious)
        
        # If avatar is unsafe, delete message and ban user immediately
        if avatar_unsafe_result:
            success = await take_action(bot, chat.id, message.message_id, user.id)
            
            # Log the action
            await log_message(
                app.state.db,
                user.id, chat.id, msg_text, link_in_bio, 
                avatar_unsafe_result, avatar_suspicious_result, 
                1, 0
            )
            
            return JSONResponse({"ok": True})
        
        # If no suspicious indicators or link in bio, skip LLM
        if not needs_classification(link_in_bio, avatar_suspicious_result):
            await log_message(
                app.state.db,
                user.id, chat.id, msg_text, link_in_bio, 
                avatar_unsafe_result, avatar_suspicious_result, 
                0, 0
            )
            return JSONResponse({"ok": True})
        
        # LLM evaluation
        with timed_execution(llm_latency):
            llm_result, latency_ms = await classify_message(
                app.state.openai_client,
                config.OPENAI_MODEL,
                user.first_name,
                bio,
                msg_text,
                avatar_suspicious_result,
                avatar_unsafe_result
            )
        
        # Update metrics if spam detected
        if llm_result == 1:
            increment_counter(spam_detected)
            # Take action
            await take_action(bot, chat.id, message.message_id, user.id)
        
        # Log into DB
        await log_message(
            app.state.db,
            user.id, chat.id, msg_text, link_in_bio, 
            avatar_unsafe_result, avatar_suspicious_result, 
            llm_result, latency_ms
        )
        
        return JSONResponse({"ok": True})


@app.get("/stats")
async def stats(payload: Dict = Depends(lambda: verify_jwt(
    jwt_secret=config.JWT_SECRET, 
    admin_ids=config.ADMIN_IDS
))):
    """
    Return statistics about spam removed and suspicious avatars caught.
    """
    return await get_stats(app.state.db)


@app.post("/toggle")
async def toggle(request: Request, payload: Dict = Depends(lambda: verify_jwt(
    jwt_secret=config.JWT_SECRET, 
    admin_ids=config.ADMIN_IDS
))):
    """
    Toggle the bot on or off.
    """
    data = await request.json()
    enabled = data.get("enabled", True)
    
    # Save state to database
    await set_bot_enabled_state(app.state.db, enabled)
    
    # Update metrics
    set_gauge(bot_enabled, 1 if enabled else 0)
    
    return {"enabled": enabled}


def main():
    """
    Run the application with uvicorn.
    """
    import uvicorn

    uvicorn.run(
        "bot.main:app",
        host=os.getenv("UVICORN_HOST", "0.0.0.0"),
        port=int(os.getenv("UVICORN_PORT", "8000")),
        log_level=config.LOG_LEVEL,
    )


if __name__ == "__main__":
    main()